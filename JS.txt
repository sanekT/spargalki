//////////////Number////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

num.toString(base;  -  возвращает строковое представление числа num в системе счисления base

Math.floor  -  округление в меньшую сторону

Math.ceil  -  округление в большую сторону

Math.round  -  округление до ближайшего целого

Math.trunc  -  производит удаление дробной части без округления: 3.1 становится 3

num.toFixed(n)  -  округляет число до n знаков после запятой и возвращает СТРОКОВОЕ представление результата

isNaN(value)  -  преобразует значение в число и проверяет является ли оно NaN, возвращает true если NaN

isFinite(value)  -  преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity

parseInt('100px') // 100

parseInt('0xff', 16) // 255

parseInt('ff', 16) // 255, без 0x тоже работает

parseFloat('12.5em') // 12.5

Math.random() * (max - min) + min

Math.max(a, b, c...) / Math.min(a, b, c...)  -  Возвращает наибольшее/наименьшее число из перечисленных аргументов.

Math.pow(n, power)  -  Возвращает число n, возведённое в степень power 


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



/////////////String//////////////////////////////////////////////////////////////////////////////////////////////////

Свойство length содержит длину строки


// получаем первый символ let str = `Hello`;
str[0] // H   -  современный способ
str.charAt(0) // H


for..of   -  перебирает строку посимвольно
	for (let char of "Hello") {
  		alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т. д.)
	}


Методы str.toLowerCase() и str.toUpperCase() меняют регистр символов: 'Interface'[0].toLowerCase() // 'i'


str.indexOf(substr, pos)  -  ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений. Поиск чувствителен к регистру

str.lastIndexOf(substr, position)  -  ищет с конца строки к её началу


Более современный метод str.includes(substr, pos) возвращает true, если в строке str есть подстрока substr, либо false, если нет.


Методы str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой
	"Widget".startsWith("Wid") // true, "Wid" — начало "Widget"
	"Widget".endsWith("get") // true, "get" — окончание "Widget"



str.slice(start [, end])  -  Возвращает часть строки от start до (не включая) end. Если аргумент end отсутствует, slice возвращает символы до конца строки. Также для start/end можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с конца строки:
	let str = "stringify";
	// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
	alert( str.slice(-4, -1) ); // gif


str.substring(start [, end])  -  Возвращает часть строки между start и end.  Это — почти то же, что и slice, но можно задавать start больше end


str.substr(start [, length])  -  Возвращает часть строки от start длины length
	let str = "stringify";
	// ring, получаем 4 символа, начиная с позиции 2
	alert( str.substr(2, 4) );
Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца


str.codePointAt(pos)  -  Возвращает код для символа, находящегося на позиции pos


String.fromCodePoint(code)  -  Создаёт символ по его коду code

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////



/////////////////Массивы//////////////////////////////////////////////////////////////////////////////////////////

arr.push('строка') -  добавляет элемент в конец

arr.pop()  -  Удаляет последний элемент из массива и возвращает его

arr.shift() -  удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым и возвращает его

arr.unshift()  -  добавляет элемент в начало массива

Методы push и unshift могут добавлять сразу несколько элементов


Массивы можно перебирать не только обычным циклом for, но и циклом for...of
	let arr = ["Яблоко", "Апельсин", "Груша"];
	for (let key in arr) {
  		alert( arr[key] ); // Яблоко, Апельсин, Груша
	}
современный синтаксис только для значений элементов (к индексам нет доступа).


С помощью свойства length можно укоротить массив  - arr.length = 2;
Таким образом, самый простой способ очистить массив – это arr.length = 0;



arr.splice(index[, deleteCount, elem1, ..., elemN])   -  удаляет, заменяет и возвращает заменёные элементы массива. Примеры
	let arr = ["Я", "изучаю", "JavaScript"];
	arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
	alert( arr ); // осталось ["Я", "JavaScript"]

	let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
	// удалить 3 первых элемента и заменить их другими
	arr.splice(0, 3, "Давай", "танцевать");
	alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]

	let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
	// удалить 2 первых элемента
	let removed = arr.splice(0, 2);
	alert( removed ); // "Я", "изучаю" <-- массив из удалённых элементов
Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0


arr.slice([start], [end])  -  возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end). Оба индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива
	let arr = ["t", "e", "s", "t"];
	alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)
	alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)


arr.concat(arg1, arg2...)  -  создаёт новый массив, в который копирует данные из других массивов и дополнительные значения


arr.forEach(function(item, index, array) {  -  позволяет запускать функцию для каждого элемента массива
  // ... делать что-то с item
});  



arr.indexOf(item, from)  -  ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1.

arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.

arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.



let result = arr.find(function(item, index, array) {   -   есть массив объектов, по заданному условию возвращает объект
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});



Метод arr.findIndex – по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1, если ничего не найдено



let results = arr.filter(function(item, index, array) {
  // если true - элемент добавляется к результату, и перебор продолжается
  // возвращается пустой массив в случае, если ничего не найдено
});  -  Синтаксис этого метода схож с find, но filter возвращает массив из всех подходящих элементов



Метод arr.map является одним из наиболее полезных и часто используемых
let result = arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
});
Например, здесь мы преобразуем каждый элемент в его длину:
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6



arr.sort(fn)  -  сортирует массив на месте, меняя в нём порядок элементов


arr.reverse() -  меняет порядок элементов в arr на обратный. Он также возвращает массив arr с изменённым порядком элементов


str.split(delim)  -  разбивает строку на массив по заданному разделителю delim


arr.join(glue)  -  создаёт строку из элементов arr, вставляя glue между ними


let value = arr.reduce(function(previousValue, item, index, array) {
  // ...
}, [initial]);  -  используется для вычисления какого-нибудь единого значения на основе всего массива. Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов
Тут мы получим сумму всех элементов массива всего одной строкой:
	let arr = [1, 2, 3, 4, 5];
	let result = arr.reduce((sum, current) => sum + current, 0);
	alert(result); // 15



Array.isArray([]) // true  -  проверяем , что параметр является массивом.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////СОБЫТИЯ МЫШИ/////////////////////////////////////////////////////////////////////////////////////


event - главный объект событий
e.button - показывает номер кнопки мыши
e.which - показывает номер кнопки мыши

onclick  -  событие по клику левой кнопки мыши

ondblclick  -  событие по двойному клику левой кнопки мыши

oncontexmenu - события по клику правой кнопкой мыши, чтобы браузер не перехватывал этот клик, надо из функции вернуть false

onmouseenter - событие при входе указателя на элемент

onmouseleave - событие при уходе указателя с элемента

onmousemove - событие возникает при каждом движении мыши

onmousedown - событие при нажатии любой кнопки мыши

onmouseup - событие при отжатии любой кнопки мыши

onwheel  -  событие прокрутки колёсика
////////////////////////////////////////////////////////////////////////////////////////////////////


/
///////////////////СОБЫТИЯ КЛАВИАТУРЫ///////////////////////////////////////////////////////////////


onkeypress  -  простое нажатие клавиши, выводит числовы, буквенные, пробел и некоторые спецсимволы. Если вывести глобальный объект event при нажатии, то увидем много интересных свойств этого нажатия


запрет вводить в инпуте цифры:
	let input = document.getElementById('num');
	input.onkeypress = function(e){
    		if(e.keyCode >= 48 && e.keyCode <= 57){
        		return false;
    		}
	}

запрет вводить в инпуте буквы:
	let input = document.getElementById('num');
	input.onkeypress = function(e){
    		if(e.keyCode > 57 || e.keyCode < 48){
        		return false;
    		}
	}
Сработает если только пользователь сам вводит эти символы, если же он скопирует и вставит в инпут, то всё вставится, тут уже нужно другое событие


onkeydown  -  событие происходит, когда нажимается любая клавиша. Есть клавиши двойные, например левый Alt и правый, чтобы понимать какой из них нажат в глобальном объекте  события есть свойство location, которое показывает 1,если левый нажат и 2 если правый.


onkeyup  -  событие происходит при отпускании клавиши.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////DOM////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////////////////